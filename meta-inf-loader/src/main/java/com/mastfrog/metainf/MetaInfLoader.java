/*
 * The MIT License
 *
 * Copyright 2022 Mastfrog Technologies.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package com.mastfrog.metainf;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import static java.nio.charset.StandardCharsets.UTF_8;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Acteur, Giulius and friends rely on annotation processors generating flat
 * files into meta-info in the JAR, which can no longer be read when using the
 * module system. So we provide an abstract class which is a layer of
 * indirection to a class within each JAR that can do that.
 * <p>
 * In order for this to work, each usage must be a distinct subclass, within the
 * module in question, and be exported by the module using a <code>provides
 * MetaInfLoader</code> clause in its module-info.
 * </p><p>
 * Implementation is typically simply to create a subclass (optionally passing
 * an ordinal to the super constructor if you want your module found in a
 * particular order), in the module in question, and provide it from the module.
 * </p><p>
 * <b>Equality/hash-code contract:</b> Since instances of MetaInfLoader can (and
 * probably will) be generated by annotation processors, it is important that
 * multiple implementations in a module do not result in duplicate sets of
 * results. So any instance is equal to another if
 * <code>getClass().getModule().equals(other.getClass().getModule())</code>, and
 * instances are collected in a <code>Set</code> on initial lookup, so if two
 * instances come from the same module, only one will survive. If you implement
 * this class directly in order to produce some non-standard behavior, you need
 * to make sure no annotation processor in that module also generates an
 * implementation, since only one can win.
 * </p>
 *
 * @author Tim Boudreau
 */
public abstract class MetaInfLoader implements Comparable<MetaInfLoader> {

    private final int ordinal;

    protected MetaInfLoader() {
        this(0);
    }

    protected MetaInfLoader(int ordinal) {
        this.ordinal = ordinal;
    }

    /**
     * Compares based on ordinals passed to the constructor.
     *
     * @param o Another instance
     * @return a comparison
     */
    @Override
    public final int compareTo(MetaInfLoader o) {
        return Integer.compare(ordinal, o.ordinal);
    }

    /**
     * Get the set of all identically named files under META-INF on the
     * classpath or module path.
     *
     * @param metaInfRelativePath A relative path
     * @return An iterable of input streams
     */
    public static Iterable<InputStream> loadAll(String metaInfRelativePath) {
        return new AllAvailableStreams(check(metaInfRelativePath));
    }

    /**
     * Concatenate all identically named fil;es under META-INF on the classpathe
     * or module path, into a new UTF-8 string.
     *
     * @param metaInfRelativePath A relative path
     * @return A string, which may be empty if no results
     * @throws IOException if something goes wrong
     */
    public static String loadAllAsString(String metaInfRelativePath) throws IOException {
        return new String(concatAll(metaInfRelativePath), UTF_8);
    }

    private static byte[] concatAll(String metaInfRelativePath) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        for (InputStream in : loadAll(metaInfRelativePath)) {
            out.write(in.readAllBytes());
        }
        return out.toByteArray();
    }

    final Iterable<InputStream> all(String metaInfRelativePath) {
        return streamsInternal(transformPath(check(metaInfRelativePath)));
    }

    /**
     * Convert the passed path to the one to look in using the module or
     * classloader. By default, prepends META-INF if not present, elides leading
     * slashes and checks that the path is non-empty.
     *
     * @param metaInfRelativePath A path passed by a caller to resolve resources
     * for
     * @return A transformed, validated path (which may or may not really exist)
     */
    protected String transformPath(String metaInfRelativePath) {
        metaInfRelativePath = metaInfRelativePath.trim();
        if (metaInfRelativePath.charAt(0) == '/') {
            metaInfRelativePath = metaInfRelativePath.substring(1);
            if (metaInfRelativePath.length() == 0) {
                throw new IllegalArgumentException("/ is not a valid path");
            }
        }
        if (!metaInfRelativePath.startsWith("META-INF")) {
            metaInfRelativePath = "META-INF/" + metaInfRelativePath;
        }
        return metaInfRelativePath;
    }

    private static String check(String metaInfRelativePath) {
        if (metaInfRelativePath == null) {
            throw new IllegalArgumentException("Null metaInfRelativePath");
        }
        if (metaInfRelativePath.isBlank()) {
            throw new IllegalArgumentException("Blank metaInfRelativePath");
        }
        return metaInfRelativePath.trim();
    }

    /**
     * Resolve a path into an iterable of streams.
     *
     * @param metaInfRelativePath The path
     * @return An iterable
     */
    protected Iterable<InputStream> streamsInternal(String metaInfRelativePath) {
        Class<?> type = getClass();
        if (type.getModule().isNamed()) {
            return new ModuleInputStreams(type, metaInfRelativePath);
        }
        return new InputStreams(metaInfRelativePath, type);
    }

    @Override
    public final String toString() {
        return getClass().getName();
    }

    @Override
    public final int hashCode() {
        return getClass().getModule().hashCode();
    }

    @Override
    public final boolean equals(Object o) {
        return o != null && o.getClass().getModule().equals(o.getClass().getModule());
    }

    private final class ModuleInputStreams implements Iterable<InputStream> {

        private final Class<?> type;
        private final String path;

        ModuleInputStreams(Class<?> type, String path) {
            this.type = type;
            this.path = path;
        }

        @Override
        public Iterator<InputStream> iterator() {
            return new StreamIter(type, path);
        }

        private static class StreamIter implements Iterator<InputStream> {

            private final Class<?> type;
            private final String path;
            private volatile boolean used;
            private InputStream theStream;

            StreamIter(Class<?> type, String path) {
                this.type = type;
                this.path = path;
            }

            private void fetch() {
                if (!used && theStream == null) {
                    try {
                        theStream = type.getModule().getResourceAsStream(path);
                    } catch (IOException ex) {
                        Logger.getLogger(MetaInfLoader.class.getName()).log(Level.SEVERE, null, ex);
                        used = true;
                    }
                }
            }

            @Override
            public boolean hasNext() {
                fetch();
                return !used;
            }

            @Override
            public InputStream next() {
                if (used) {
                    throw new NoSuchElementException();
                }
                if (theStream == null) {
                    fetch();
                }
                used = true;
                InputStream in = theStream;
                if (in == null) {
                    throw new NoSuchElementException();
                }
                return in;
            }
        }
    }

    // Fallback for non-modular use
    private static final class InputStreams implements Iterable<InputStream> {

        private final String metaInfRelativePath;
        private final Class<?> type;

        public InputStreams(String metaInfRelativePath, Class<?> type) {
            this.metaInfRelativePath = metaInfRelativePath;
            this.type = type;
        }

        @Override
        public Iterator<InputStream> iterator() {
            try {
                Enumeration<URL> urls = type.getClassLoader()
                        .getResources(metaInfRelativePath);
                return new UrlEnumIter(urls);
            } catch (IOException ex) {
                Logger.getLogger(MetaInfLoader.class.getName()).log(Level.SEVERE,
                        "Failed getting stream for " + metaInfRelativePath
                        + " from " + type.getName(), ex);
                return Collections.emptyIterator();
            }
        }

        static final class UrlEnumIter implements Iterator<InputStream> {

            private final Enumeration<URL> urls;

            public UrlEnumIter(Enumeration<URL> urls) {
                this.urls = urls;
            }

            @Override
            public boolean hasNext() {
                return urls.hasMoreElements();
            }

            @Override
            public InputStream next() {
                URL u = null;
                try {
                    u = urls.nextElement();
                    return u.openStream();
                } catch (IOException ex) {
                    Logger.getLogger(MetaInfLoader.class.getName()).log(Level.SEVERE,
                            "Could not open stream for " + u, ex);
                    return InputStream.nullInputStream();
                }
            }
        }
    }

    private static final class AllAvailableStreams implements Iterable<InputStream> {

        private final String path;

        AllAvailableStreams(String path) {
            this.path = path;
        }

        @Override
        public Iterator<InputStream> iterator() {
            ServiceLoader<MetaInfLoader> items = ServiceLoader.load(MetaInfLoader.class);
            Set<MetaInfLoader> ldrs = new HashSet<>(16);
            List<Iterator<InputStream>> iters = new ArrayList<>();
            for (MetaInfLoader ldr : items) {
                ldrs.add(ldr);
            }
            List<MetaInfLoader> list = new ArrayList<>(ldrs);
            Collections.sort(list);
            for (MetaInfLoader ldr : list) {
                iters.add(ldr.all(path).iterator());
            }
            return new MergeIterator<>(iters);
        }
    }

    private static final class MergeIterator<T> implements Iterator<T> {
        // Copy of class from CollectionUtils - we *really* want minimal
        // dependencies for this libraryl.

        private final LinkedList<Iterator<T>> iterators = new LinkedList<>();

        MergeIterator(Collection<Iterator<T>> iterators) {
            this.iterators.addAll(iterators);
        }

        private Iterator<T> iter() {
            if (iterators.isEmpty()) {
                return null;
            }
            Iterator<T> result = iterators.get(0);
            if (!result.hasNext()) {
                iterators.remove(0);
                return iter();
            }
            return result;
        }

        @Override
        public boolean hasNext() {
            Iterator<T> curr = iter();
            return curr != null && curr.hasNext();
        }

        @Override
        public T next() {
            Iterator<T> iter = iter();
            if (iter == null) {
                throw new NoSuchElementException();
            }
            return iter.next();
        }

        @Override
        public void remove() {
            Iterator<T> iter = iter();
            if (iter == null) {
                throw new NoSuchElementException();
            }
            iter.remove();
        }
    }
}
